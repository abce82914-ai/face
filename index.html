<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Recognition</title>
  <style>
    html, body { height: 100%; margin: 0; background: #f3f3f3; font-family: 'Segoe UI', Arial, sans-serif; }
    .main-layout { display: flex; height: 100vh; }
    .cam-section { flex: 1.5; background: #222; min-width: 380px; display: flex; align-items: center; justify-content: center; position: relative; }
    #cameraPreview { width: 98%; max-width: 680px; aspect-ratio: 4/3; background: #000; border-radius: 14px; margin: auto; box-shadow: 0 6px 24px rgba(0,0,0,0.23); display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
    video#previewVideo { width: 100%; height: 100%; border-radius: 14px; object-fit: cover; background: #000; display: none; }
    canvas#overlayCanvas { position: absolute; left: 0; top: 0; pointer-events: none; border-radius: 14px; display: none; z-index: 5; }
    #overlayText { color: #767676; font-size: 1.2em; text-align: center; position: absolute; width: 100%; left: 0; top: 44%; pointer-events: none; user-select: none; z-index: 2; }
    .processing-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.55); display: flex; align-items: center; justify-content: center; color: white; font-size: 1.1em; border-radius: 14px; z-index: 10; display: none; }
    .controls-section { flex: 1; background: #fff; border-left: 2px solid #ddd; padding: 34px 26px 20px 26px; display: flex; flex-direction: column; align-items: flex-start; overflow-y: auto; }
    h1 { margin-top: 0; font-size: 2em; font-weight: 600; letter-spacing: 1px; }
    .form-row { margin-bottom: 16px; display:flex;gap:9px; width: 100%; }
    input, select { padding: 9px 11px;  border-radius: 6px;  border: 1.5px solid #d5d7e0;  font-size: 0.96em;  background: #fcfcff;  flex: 1;  max-width: 46%;  /* ðŸ‘ˆ limits width of select box so no scrollbar */  box-sizing: border-box;}
    button.action-btn { padding: 9px 17px; border-radius: 7px; border: none; font-size: 1em; font-weight: 500; background: #3662e3; color: #fff; cursor: pointer; margin-right: 8px; margin-bottom: 6px; margin-top: 6px; transition: background 0.14s; }
    button.action-btn:hover { background: #2242ba; }
    button.action-btn.delete { background: #e04646; margin-right:0;}
    #status { min-height: 18px; color: #2d53ad; font-weight: 500; margin: 7px 0 14px 0; }
    .users-label { margin-top: 18px;margin-bottom: 2px;font-weight:500;}
    .users-list { margin: 0; list-style: none; padding: 0; max-height: 210px; width: 100%; overflow-y: auto; }
    .user-row { background: #f4f6fb; margin-bottom: 7px; border-radius: 5px; padding: 7px 11px; display: flex; align-items: center; justify-content: space-between; font-size: 1em; }
    @media (max-width: 950px) { .main-layout { flex-direction: column;height:auto;} .cam-section { min-height: 280px; min-width: 0; } .controls-section { border-left:none;padding:21px 8px 9px 8px;} #cameraPreview { width: 95%; max-width: 480px; } }
  </style>
</head>
<body>
  <div class="main-layout">
    <div class="cam-section">
      <div id="cameraPreview">
        <video id="previewVideo" autoplay playsinline muted></video>
        <canvas id="overlayCanvas"></canvas>
        <div id="overlayText">Camera preview here<br>(click Register / Recognize to start)</div>
        <div class="processing-overlay" id="processingOverlay">Processing...</div>
      </div>
    </div>

    <div class="controls-section">
      <h1>Face Recognition</h1>

      <div class="form-row">
        <input id="name" placeholder="User name" autocomplete="off"/>
        <select id="cameraSelect"></select>
      </div>

      <div>
        <button class="action-btn" onclick="refreshDevices()">Refresh Cameras</button>
        <button class="action-btn" onclick="startRegistration()">Register</button>
        <button class="action-btn" onclick="startRecognition()">Recognize</button>
        <button class="action-btn delete" onclick="stopAll()">STOP / CLOSE</button>
      </div>

      <div id="status"></div>

      <div class="users-label">Registered Users:</div>
      <ul class="users-list" id="usersList"></ul>
    </div>
  </div>

<script>
/*
  Fixed JS:
  - request permission first, then enumerateDevices
  - proper canvas sizing to match video pixels
  - recognition draws bbox + label on overlay canvas in real-time
*/

const video = document.getElementById('previewVideo');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayText = document.getElementById('overlayText');
const processingOverlay = document.getElementById('processingOverlay');
const status = document.getElementById('status');
let localStream = null;
let recognizing = false;
let recognizeInterval = null;

/* 1) Ensure permission then enumerate devices */
async function ensurePermissionAndEnumerate() {
  try {
    // small hidden permission request to allow enumerateDevices to show labels
    const p = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    // immediately stop the tracks we opened for permission
    p.getTracks().forEach(t => t.stop());
  } catch (e) {
    console.warn("UserMedia permission not granted or not required yet:", e);
    // continue â€” enumerateDevices may still list deviceIds without labels
  }
  return enumerateVideoDevices();
}

async function enumerateVideoDevices() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === 'videoinput');
    const sel = document.getElementById('cameraSelect');
    sel.innerHTML = '';
    cams.forEach((c, i) => {
      const opt = document.createElement('option');
      opt.value = c.deviceId;
      // Some browsers hide labels until permission â€” show fallback
      opt.text = c.label || `Camera ${i+1}`;
      sel.appendChild(opt);
    });
    if (cams.length === 0) {
      const opt = document.createElement('option');
      opt.value = "";
      opt.text = "No camera found";
      sel.appendChild(opt);
    }
    console.log("Devices enumerated:", cams);
    return cams;
  } catch (err) {
    console.error("enumerateVideoDevices error:", err);
    throw err;
  }
}

async function startPreview(deviceId = null) {
  stopPreview();
  try {
    const constraints = { video: {} };
    if (deviceId) constraints.video.deviceId = { exact: deviceId };
    else constraints.video.facingMode = "user";
    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = localStream;
    video.style.display = 'block';
    overlayText.style.display = 'none';
    overlayCanvas.style.display = 'block';

    // Wait until video metadata available
    await new Promise(resolve => {
      if (video.readyState >= 2 && video.videoWidth) {
        resolve();
      } else {
        video.onloadedmetadata = () => resolve();
      }
      // fallback in case onloadedmetadata doesn't fire quickly
      setTimeout(() => resolve(), 1000);
    });

    // set canvas to match intrinsic video pixel size
    resizeOverlayToVideo();
    window.addEventListener('resize', resizeOverlayToVideo);
    console.log("Preview started:", video.videoWidth, video.videoHeight);
  } catch (e) {
    console.error("startPreview error:", e);
    overlayText.style.display = 'block';
    video.style.display = 'none';
    overlayCanvas.style.display = 'none';
    status.textContent = 'Camera access denied or not available.';
  }
}

function stopPreview() {
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }
  video.srcObject = null;
  video.style.display = 'none';
  overlayText.style.display = 'block';
  overlayCanvas.style.display = 'none';
  clearOverlay();
  window.removeEventListener('resize', resizeOverlayToVideo);
}

function resizeOverlayToVideo() {
  // We set canvas pixel dims to video.videoWidth/Height (intrinsic) for precise mapping
  const vw = video.videoWidth || video.clientWidth || 640;
  const vh = video.videoHeight || video.clientHeight || 480;
  overlayCanvas.width = vw;
  overlayCanvas.height = vh;

  // CSS size should match the displayed size
  const rect = video.getBoundingClientRect();
  overlayCanvas.style.width = rect.width + 'px';
  overlayCanvas.style.height = rect.height + 'px';
  overlayCanvas.style.left = video.offsetLeft + 'px';
  overlayCanvas.style.top = video.offsetTop + 'px';
}

function clearOverlay() {
  const ctx = overlayCanvas.getContext('2d');
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
}

function drawBoxOnOverlay(bbox, name, img_w, img_h) {
  const ctx = overlayCanvas.getContext('2d');
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  if (!bbox) return;

  // map source image coords -> canvas pixel coords
  const scaleX = overlayCanvas.width / img_w;
  const scaleY = overlayCanvas.height / img_h;

  const x = bbox[0] * scaleX;
  const y = bbox[1] * scaleY;
  const w = bbox[2] * scaleX;
  const h = bbox[3] * scaleY;

  const color = (name && name !== 'Unknown') ? 'rgba(0,200,0,0.95)' : 'rgba(200,0,0,0.95)';

  ctx.lineWidth = Math.max(2, Math.round(overlayCanvas.width / 220));
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.strokeRect(x, y, w, h);

  // label
  const label = name || 'Unknown';
  const fontSize = Math.max(12, Math.round(overlayCanvas.width / 32));
  ctx.font = `${fontSize}px Arial`;
  const textWidth = ctx.measureText(label).width;
  const pad = 6;
  let labelX = x;
  let labelY = y - (fontSize + pad);
  if (labelY < 0) labelY = y + h + 4; // draw below if not enough space above
  ctx.fillRect(labelX - 1, labelY, textWidth + pad*1.2, fontSize + pad/1.2);
  ctx.fillStyle = '#fff';
  ctx.fillText(label, labelX + pad/4, labelY + fontSize - 4);
}

/* capture frame as dataURL using intrinsic resolution */
function dataUrlFromVideoFrame() {
  const w = video.videoWidth;
  const h = video.videoHeight;
  if (!w || !h) return null;
  const c = document.createElement('canvas');
  c.width = w;
  c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(video, 0, 0, w, h);
  return c.toDataURL('image/jpeg', 0.85);
}

/* ---------- Registration ---------- */
async function startRegistration() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert("getUserMedia not supported in this browser.");
    return;
  }
  const name = document.getElementById('name').value.trim();
  if (!name) { alert('Enter name'); return; }

  const deviceId = document.getElementById('cameraSelect').value || null;
  await startPreview(deviceId);

  // capture multiple frames for a robust registration
  const COUNT = 12;
  const INTERVAL = 300;
  processingOverlay.style.display = 'flex';
  processingOverlay.textContent = 'Capturing images...';
  status.textContent = 'Capturing images for registration...';

  const images = [];
  for (let i = 0; i < COUNT; i++) {
    await new Promise(r => setTimeout(r, INTERVAL));
    const d = dataUrlFromVideoFrame();
    if (d) images.push(d);
  }

  processingOverlay.textContent = 'Uploading...';
  try {
    const res = await fetch('/register_images', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: name, images: images })
    });
    const j = await res.json();
    status.textContent = j.message || JSON.stringify(j);
    console.log("register response:", j);
  } catch (e) {
    console.error("register error:", e);
    status.textContent = 'Registration failed';
  } finally {
    processingOverlay.style.display = 'none';
    stopPreview();
    await refreshUsers();
  }
}

/* ---------- Recognition ---------- */
async function startRecognition() {
  if (recognizing) return;
  const deviceId = document.getElementById('cameraSelect').value || null;
  await startPreview(deviceId);

  recognizing = true;
  processingOverlay.style.display = 'flex';
  processingOverlay.textContent = 'Recognizing...';
  status.textContent = 'Recognition started';

  // frequency - tweak this if CPU/network is heavy
  const INTERVAL_MS = 700;

  recognizeInterval = setInterval(async () => {
    if (!recognizing) return;
    const frameData = dataUrlFromVideoFrame();
    if (!frameData) return;
    try {
      const res = await fetch('/recognize_image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image: frameData })
      });
      const j = await res.json();
      // debug
      // console.log('recognize resp', j);
      if (j && j.status === 'ok') {
        // draw on overlay
        if (j.bbox) {
          drawBoxOnOverlay(j.bbox, j.name, j.img_w, j.img_h);
        } else {
          clearOverlay();
        }
        // keep a small status text as well
        if (j.name && j.name !== 'Unknown') {
          status.textContent = `Identified: ${j.name} (dist ${j.distance.toFixed(3)})`;
        } else {
          status.textContent = `Unknown`;
        }
      } else if (j && j.status === 'error') {
        clearOverlay();
        console.warn('recognize error', j.message);
      } else {
        clearOverlay();
      }
    } catch (e) {
      console.error("recognize fetch error:", e);
      clearOverlay();
    }
  }, INTERVAL_MS);
}

function stopRecognition() {
  recognizing = false;
  if (recognizeInterval) {
    clearInterval(recognizeInterval);
    recognizeInterval = null;
  }
  processingOverlay.style.display = 'none';
  status.textContent = 'Recognition stopped';
  stopPreview();
  clearOverlay();
}

/* ---------- Helpers ---------- */
async function refreshUsers() {
  try {
    const res = await fetch('/users');
    const j = await res.json();
    const ul = document.getElementById('usersList');
    ul.innerHTML = '';
    if (!j.users || j.users.length === 0) {
      const li = document.createElement('li');
      li.textContent = 'No users';
      li.style.padding = '8px 0';
      li.style.color = '#bbb';
      ul.appendChild(li);
    } else {
      j.users.forEach(u => {
        const li = document.createElement('li');
        li.className = 'user-row';
        li.innerHTML = `<span style="flex:1">${u}</span><button class="action-btn delete" onclick="deleteUser('${u}')">Delete</button>`;
        ul.appendChild(li);
      });
    }
  } catch (e) {
    console.error("refreshUsers error:", e);
  }
}

async function refreshDevices() {
  status.textContent = 'Refreshing devices...';
  try {
    await ensurePermissionAndEnumerate();
    await refreshUsers();
    status.textContent = 'Devices refreshed';
  } catch (e) {
    console.error("refreshDevices error:", e);
    status.textContent = 'Failed to enumerate devices';
  }
}

async function deleteUser(name) {
  if (!confirm(`Delete user "${name}"?`)) return;
  try {
    const res = await fetch('/delete', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ name })
    });
    const j = await res.json();
    status.textContent = j.message;
    await refreshUsers();
  } catch (e) {
    console.error("deleteUser error:", e);
  }
}

function stopAll() {
  stopRecognition();
  stopPreview();
  status.textContent = "Stopped camera/recognition";
}

/* ---------- init ---------- */
window.onload = async () => {
  // try to refresh devices (permission requested internally)
  await refreshDevices();
};
</script>
</body>
</html>
